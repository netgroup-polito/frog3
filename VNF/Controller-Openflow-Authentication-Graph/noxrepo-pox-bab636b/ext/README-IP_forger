CONTENTS OF THIS FILE
---------------------
 * Execution
 * Paramenters file
 * Implementation details


EXECUTION
------------
The Controller should be executed with the command:

	./pox.py IP_forger



PARAMENTERS FILE
-----------------
The configuration pararemeters needed by the module are contained in the "controller.conf" file, that 
is read by the "Config.py" class. Here a brief description of them:
	
	- Section [my_infos] contains information related to the Controller:
		- "ip": is the IP of the Controller
		- "tcp_port": the listening TCP port number for the socket that communicates with the Capitve Portal.
		              It must be a non-privileged port.
		- "user_ports" : the port number of the OpenFlow switch from which the users packets are coming
		                 from.
    
    - Section [captive_portal_infos] contains the Captive Portal informations:
    	- "ip": the IP address of the Captive Portal
    	- "tcp_port" : the TCP port on which the Captive Portal web server is listening
    	- "mac_address" : the MAC address of the Captive Portal
    	- "switch_port" : the port number of the OpenFlow switch where the Captive portal is attached

    - Section [log] contains log related configuration


IMPLEMENTATION DETAILS
-----------------------

All the code of the developed POX component is contained in the "IP_forger.py" file.

At startup the entry point class (IP_forger) register itself as a listener to OpenFlow messages, in order 
to be notified when a new OpenFlow connection to a switch is established. For every new connection:

	- a "IPForger" class is istantiated: is the class that reacts to PACKET_IN and installs FLOWMODs
	- a new thread for the function "my_socket" is launched: this function is used for the communication
	  to the Captive Portal

"IPForger" class:

	After registering itself as a listener for the messages of that particular OpenFlow connection (received as 
	paramenter), this class will implement the method _handle_PacketIn, that is called when a new PACKET_IN
	message is received.

	When a PACKET_IN is received the _handle_PacketIn function checks if the port from which it was received
	was already known (other packets where already received from that port). If not the function will install
	some basic FLOWMODs:

		- If the receiving port is not the user port a FLOWMOD with NORMAL action is installed for all the traffic 
		  coming from that port (it only matches the input port), allowing traditional L2 forwarding behaviour

		- If the receiving port is the user port the following FLOWMODS are installed, all of them with a basic
		  match in_port = user_port :
				
				- priority = 1, action = DROP; this is to be sure that we have a basic flow that drop all the traffic

				- priority = 100, matches for DNS requests, action = NORMAL; let the DNS requests pass

				- priority = 100, matches for ARP traffic, action = NORMAL; let the ARP messages pass
				
				- priority = 100, matches for DHCPDISCOVER, action = NORMAL; let DHCPDISCOVER messages pass

				- priority = 1000, matches for HTTP traffic (tp_dst = 80), action = CONTROLLER; the HTTP request
				  will reach the controller through a PACKET_IN

	After that, the next HTTP packet, generated by the user, will reach the controller and other operations are performed 
	upon his receiption:

		- First of all the user informations are stored: the association between the IP and the MAC addresses of the user
		  are stored or updated

		- After that, if the user is not currently authenticated, two FLOWMODS are installed:

			- The first one, for the WEB traffic from the user to the captive portal, has: 
				- priority = 10000 
				- matches:
					- in_port equal to the user port
					- source MAC address of the user
					- destination IP of the received packet
					- TCP destination port 80
					- TCP source port of the received packet, in order to intercept the different TCP connections, if multiple 
					  are opened
				- actions:
					- Change destination MAC address to the MAC of the captive portal
					- Change destination IP address to the IP of the captive portal 
					- Change destination TCP port to the TCP port of the web server of the captive portal
					- OUTPUT = captive portal switch port number

			- The second match, for the traffic from the captive portal to the user, has:
				- priority = 10000 
				- matches:
					- destination IP equal to the source IP of the received packet (the user IP)
					- source IP equal to the captive portal IP
					- TCP destination port equal to the TCP source port of the received packet
				- actions:
					- Change source IP address to the destination IP of the received packet
					- Change source TCP port to the destination TCP port of the received packet
					- OUTPUT = port from which the PACKET_IN was received, i.e. the user port

		Those two FLOWMODS have an expiration timeout, idle_timeout, of 30 seconds.
		Those flows are actually "redirecting" the HTTP requests of the user to the captive portal, changing some headers
		information in order to be accepted by the TCP/IP stack of the captive portal.


"my_socket" function:

	This function is responsible to the communication with the Captive Portal and performs two basic operations:

		- When the Captive portal sends a message with type = "Auth_OK", that also include the IP address of the user
		  that has completed the authentication process, it replies with the user MAC address that was stored previously for
		  that IP.

		- When the Captive portal sends a message with type = "Deploy_OK", meaning the user graph has been succesful deployed,
		  it sets the user as authenticated and removes the FLOWMODS for the traffic coming from that user (in_port = user port, 
		  source MAC = user MAC)